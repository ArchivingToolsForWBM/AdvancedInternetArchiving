<html>
	<head>
		<style>
			html {
			background-color: black;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			input[type='text'] { font-family: monospace;}
			input[type='number'] { font-family: monospace;}
			
			td label {   /* thanks to Patrick McElhaney - https://stackoverflow.com/questions/9739259/tick-a-checkbox-in-a-table-cell-by-clicking-anywhere-in-the-table-cell , causes table cells with labels inside them to focus onto whats inside a label */
				display: block;
				text-align: center;
			}
			
		</style>
	</head>
<body>
<h1 style="text-align: center;">General URL converter</h1>
<p>This is a general tool to convert multiple different types of URLs.</p>
<p>To edit or add converters, open this HTML file using a text editor (such as notepad++), and see <kbd>ListOfConverters</kbd></p>

<p>Enter text that have URLs in them here</p>
<label><input type="checkbox" id="AutoUpdate" onchange="Auto_update()" checked>Auto update</label><br>
<textarea style="white-space: pre; overflow-wrap: normal; overflow-x: scroll;" id="Input_EnteredURLs" cols="100" rows="30" oninput="Auto_update()"></textarea><br>
Sort:
<ul>
	<li><label><input type="radio" name="SortSetting" checked onchange="Auto_update()" id="SortSetting_None">None (be in the same order as the input)</label></li>
	<li><label><input type="radio" name="SortSetting" onchange="Auto_update()" id="SortSetting_ABC">Alphabetically</label> (<label><input type="radio" name="SortSetting" onchange="Auto_update()" id="SortSetting_ABC_Reverse">Reverse</label>)</li>
</ul>
Other:
<ul>
	<li><label><input type="checkbox" id="MiscSetting_IncludeURLsNotMatched" checked onchange="Auto_update()">Include URLs that did not match with any of the converters</label></li>
</ul>
<hr>
<textarea style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; background-color : #000000; color : #ffffff;" id="HTML_OutputString" cols="100" rows="30" readonly></textarea><br>
<button onclick="setClipboard(document.getElementById('HTML_OutputString').value)" id="Button_CopyOutput">Copy to clipboard</button><span id="CopiedTextMessage"></span><br><br>
<script>
	//An array containing a list of objects specifying the replacement.
	//-When "Type" is "normal": performs a simple replacement, the attributes are:
	//--FindWhat: <Regex>: A regular expression the URLs in the input must match with to identify what appropriate replacement to perform a URL conversion
	//  NOTE: I recommend matching the entire string if you do not fully understand how the URL format of a given website work.
	//--ReplaceWith: An array containing 1 or more items to replace with
	//--IncludeOriginal: <Boolean>: False if you only wanted the converted URL to be included in the output, true if you want to include
	//-When "Type" is "pagination": This will generate each URL of each page number of the same kind, based on the highest page number of the matching kind that exists in the input,
	// Example, if you provide similar URLs with the difference being the page numbers:
	//--https://example.com/test?page=1 (usually "?page=1" is omitted but still works)
	//--https://example.com/test?page=4
	//--https://example.com/test?page=10
	// It will generate from page 1 to page 10. If you also have the same thing but different numbers and have "test" be a different string, it will
	// generate all of them each with their OWN (no mixup, string before and after number must match) maximum numbers.
	//--FindWhat: <Regex>: Same as above, but must match only the page number (in addition to making sure the URL pattern match), as string.split is being used.
	//---Make sure you use non-capturing group "(?:noncapturing)") since the array it split into should only contain URL string before and after the number.
	//---Must use in a way that it only matches the number in the substring, it must avoid matching/including any text that aren't page numbers.
	//--PageNumberStartsAt: Page number to start at from counting from that number to the highest number. Some sites may have their page number start at 0, some at 1.
	
		const ListOfConverters = [
			{
				//Example 1: Twitter image URLs
				//Example test: https://pbs.twimg.com/media/CBAoaU1UwAIUPIc?format=jpg
				Type:"normal",
				FindWhat:/^https:\/\/pbs\.twimg\.com\/media\/([^\s\?]+\?format=[a-zA-Z0-9]+).*$/, //If this doesn't match the entire string, the substring that is not matched will be included, making the URL invalid
				ReplaceWith:["https://pbs.twimg.com/media/$1&name=orig", "https://pbs.twimg.com/media/$1&name=thumb"],
				IncludeOriginal:false
			},
			{
				Type:"pagination",
				FindWhat:/(?:(?<=^https:\/\/example\.com\/[a-zA-Z0-9_]+\?page=))\d+(?:(?=$))/,
				PageNumberStartsAt:1
			}
		]
	function Auto_update() {
		if (document.getElementById("AutoUpdate").checked) {
			MainFunction()
		}
	}
	//Copy text from textarea
		function setClipboard(String) {
			//Credit goes to Mozilla: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/write
			const type = "text/plain";
			const blob = new Blob([String], { type });
			const data = [new ClipboardItem({ [type]: blob })];
	
			navigator.clipboard.write(data).then(
				() => {
				/* success */
					document.getElementById("CopiedTextMessage").innerHTML = " <span style='color: #00FF00;'>Copied!</span>"
					setTimeout(DeleteCopyMessage, 1500)
				},
				() => {
				/* failure */
					document.getElementById("CopiedTextMessage").innerHTML = " <span style='color: #FF0000;'>Copy failed!</span>"
					setTimeout(DeleteCopyMessage, 1500)
				}
			);
		}
		function DeleteCopyMessage() {
			document.getElementById("CopiedTextMessage").innerHTML = ""
		}
	
	function MainFunction() {
		let ListOfURLs = document.getElementById("Input_EnteredURLs").value.match(/ttp(s)?\:\/\/(?!data:)[^\s\"\']+/g) //Why ttps instead of https? Blame firefox's URL truncation of long URLs.
		if (ListOfURLs == null) {
			ListOfURLs = [] //failsafe, prevents Array.map from performing a null which on the browser, would do nothing (if user enters a string with no valid URL).
		}
		ListOfURLs = ListOfURLs.map(ArrayElement => {
			
			let URLObject = {
				URL:ArrayElement.replace(/^ttp(s)?/, "http$1").replace(/#.*$/, ""), //Revert the URL to have the "h" of the http/https, and remove fragment identifier
				HaveBeenChecked:false //This is used to check for duplicate or 2 URLs being similar (same URL but different page number)
			}
			return URLObject
		});
		
		let OutputSet = new Set()

		//Some loops had to use a for loop instead of array.foreach because
		//-Not recommended for concurrent modification since we are checking for potential same/similar URL
		//-We check every possible combinations, so there are two index numbers with the second one starting at FirstIndex+1 instead of 0.
		for (let i = 0; i < ListOfURLs.length; i++) { //Loop through every entered URL by the user
			let UrlMatchedAnyConverter = false
			if (ListOfURLs[i].HaveBeenChecked == false) { //Skip pagination URLs that have been checked by inner loop (optimization purposes)
				ListOfConverters.forEach(Converter => { //For each URL the user entered, loop through converters
					if (Converter.FindWhat.test(ListOfURLs[i].URL)) { //If URL matches one or more of the converters (a URL gets to loop through multiple converters)
						UrlMatchedAnyConverter = true
						if (Converter.IncludeOriginal) {
							OutputSet.add(ListOfURLs[i].URL)
						}
						if (Converter.Type == "normal") {
							Converter.ReplaceWith.forEach(ReplaceWithText => {
								OutputSet.add(ListOfURLs[i].URL.replace(Converter.FindWhat, ReplaceWithText))
							});
						} else if (Converter.Type == "pagination") {
							let HighestPageNumberSoFar = parseInt(ListOfURLs[i].URL.match(Converter.FindWhat)[0], 10)
							let PartsOfURLSame = ListOfURLs[i].URL.split(Converter.FindWhat)
							for (let i2 = i+1; i2 < ListOfURLs.length; i2++) { //Loop to find a potential same URL but with higher page number
								PartsOfURLSame2 = ListOfURLs[i2].URL.split(Converter.FindWhat)
								if (Converter.FindWhat.test(ListOfURLs[i2].URL) && (PartsOfURLSame[0] == PartsOfURLSame2[0]) && (PartsOfURLSame[1] == PartsOfURLSame2[1])) { //if regex and all parts of the URL the same ignoring page number, compare the page number
									HighestPageNumberSoFar = Math.max(HighestPageNumberSoFar, parseInt(ListOfURLs[i2].URL.match(Converter.FindWhat)[0], 10))
									ListOfURLs[i2].HaveBeenChecked = true //Don't check this again when the outer loop advances
								}
							}
							//We now have the maximum number based on the user input
							for (let i2 = Converter.PageNumberStartsAt; i2 <= HighestPageNumberSoFar; i2++) { //Generate a URL of each page
								OutputSet.add(PartsOfURLSame[0] + i2.toString(10) + PartsOfURLSame[1])
							}
						}
						
					}
					if ((UrlMatchedAnyConverter == false)&&document.getElementById("MiscSetting_IncludeURLsNotMatched").checked) {
						OutputSet.add(ListOfURLs[i].URL)
					}
				});
			}
		}
		
		let OutputArray = Array.from(OutputSet)
		if (document.getElementById("SortSetting_ABC").checked) {
			OutputArray.sort()
		} else if (document.getElementById("SortSetting_ABC_Reverse").checked) {
			OutputArray.sort((a, b) => {
				if (a === b) {
					return 0;
				} else {
					return (a < b) ? 1 : -1;
				}
			});
		}
		let OutputString = ""
		
		OutputArray.forEach((ArrayElement, ArrayIndex, ArrayItself) => {
			OutputString += ArrayElement
			if (ArrayIndex != ArrayItself.length - 1) {
				OutputString += "\n"
			}
		});
		document.getElementById("HTML_OutputString").value = OutputString
	}
</script>