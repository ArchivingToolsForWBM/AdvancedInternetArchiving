<html>
	<head>
		<style>
			html {
			background-color: black;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			input[type='text'] { font-family: monospace;}
			input[type='number'] { font-family: monospace;}
			
			td label {   /* thanks to Patrick McElhaney - https://stackoverflow.com/questions/9739259/tick-a-checkbox-in-a-table-cell-by-clicking-anywhere-in-the-table-cell , causes table cells with labels inside them to focus onto whats inside a label */
				display: block;
				text-align: center;
			}
			
		</style>
	</head>
<body>
<h1 style="text-align: center;">General URL converter</h1>
<p>This is a general tool to convert multiple different types of URLs.</p>
<p>To edit or add converters, open this HTML file using a text editor (such as notepad++), and see <kbd>ListOfConverters</kbd></p>

<p>Enter text that have URLs in them here</p>
<label><input type="checkbox" id="AutoUpdate" onchange="Auto_update()" checked>Auto update</label><br>
<textarea style="white-space: pre; overflow-wrap: normal; overflow-x: scroll;" id="Input_EnteredURLs" cols="100" rows="30" oninput="NotifyInputChanged(); Auto_update()"></textarea><br>
Filter:
<button onclick="ChangeFilterSettings('CheckboxFilters', 1); Auto_update()">Check all</button><button onclick="ChangeFilterSettings('CheckboxFilters', 0); Auto_update()">Uncheck all</button><button onclick="ChangeFilterSettings('CheckboxFilters', 2); Auto_update()">Invert</button>
<ul>
	<li><label><input type="checkbox" class="CheckboxFilters" checked onchange="Auto_update()" id="FilterSetting_original">Original (same URL as you entered)</label></li>
	<li><label><input type="checkbox" class="CheckboxFilters" checked onchange="Auto_update()" id="FilterSetting_converted">Converted URLs (replaced substrings)</label></li>
	<li><label><input type="checkbox" class="CheckboxFilters" checked onchange="Auto_update()" id="FilterSetting_pagination">pagination (have page number in URL)</label></li>
	<li><label><input type="checkbox" class="CheckboxFilters" onchange="Auto_update()" id="FilterSetting_blacklisted">Blacklisted (remove unwanted URLs such as ads, various google URLs, etc.)</label></li>
	<li><label><input type="checkbox" class="CheckboxFilters" checked onchange="Auto_update()" id="FilterSetting_other">other (URL not matching any of the listed patterns)</label></li>
</ul>
Sort:
<ul>
	<li><label><input type="radio" name="SortSetting" checked onchange="Auto_update()" id="SortSetting_None">None (be in the same order as the input, and also based on the converters)</label></li>
	<li><label><input type="radio" name="SortSetting" onchange="Auto_update()" id="SortSetting_ABC">Alphabetically</label> (<label><input type="radio" name="SortSetting" onchange="Auto_update()" id="SortSetting_ABC_Reverse">Reverse</label>)</li>
	<li><label><input type="radio" name="SortSetting" onchange="Auto_update()" id="SortSetting_IdentifiedType">By Identified type</label> (<label><input type="radio" name="SortSetting" onchange="Auto_update()" id="SortSetting_IdentifiedType_Reverse">Reverse</label>)</li>
</ul>
<hr>
<textarea style="white-space: pre; overflow-wrap: normal; overflow-x: scroll; background-color : #000000; color : #ffffff;" id="HTML_OutputString" cols="100" rows="30" readonly></textarea><br>
<button onclick="setClipboard(document.getElementById('HTML_OutputString').value)" id="Button_CopyOutput">Copy to clipboard</button><span id="CopiedTextMessage"></span><br><br><br>

<span id="URL_OutputTable"></span>
<script>
	var SavedOutput = []
	var InputChanged = false
	function NotifyInputChanged() {
		InputChanged = true
	}
	//An array containing a list of objects specifying the replacement.
	//-When "Type" is "normal": performs a simple replacement, the attributes are:
	//--FindWhat: <Regex>: A regular expression the URLs in the input must match with to identify what appropriate replacement to perform a URL conversion
	//  NOTE: I recommend matching the entire string if you do not fully understand how the URL format of a given website work.
	//--ReplaceWith: An array containing 1 or more items to replace with
	//--IncludeOriginal: <Boolean>: False if you only wanted the converted URL to be included in the output, true if you want to include
	//-When "Type" is "pagination": This will generate each URL of each page number of the same kind, based on the highest page number of the matching kind that exists in the input,
	// Example, if you provide similar URLs with the difference being the page numbers:
	//--https://example.com/test?page=1 (usually "?page=1" is omitted but still works)
	//--https://example.com/test?page=4
	//--https://example.com/test?page=10
	// It will generate from page 1 to page 10. If you also have the same thing but different numbers and have "test" be a different string, it will
	// generate all of them each with their OWN (no mixup, string before and after number must match) maximum numbers.
	//--FindWhat: <Regex>: Same as above, but must match only the page number (in addition to making sure the URL pattern match), as string.split is being used.
	//---Make sure you use non-capturing group "(?:noncapturing)") since the array it split into should only contain URL string before and after the number.
	//---Must use in a way that it only matches the number in the substring, it must avoid matching/including any text that aren't page numbers.
	//--PageNumberStartsAt: Page number to start at from counting from that number to the highest number. Some sites may have their page number start at 0, some at 1.
	//-When "Type" is "blacklisted", it can be filtered (filter setting). Only "FindWhat" is needed, anything that matches this regex will be labeled as blacklisted.
	
		const ListOfConverters = [
			{
				//Example 1: Twitter image URLs
				//Example test: https://pbs.twimg.com/media/CBAoaU1UwAIUPIc?format=jpg
				Type:"normal",
				FindWhat:/^https:\/\/pbs\.twimg\.com\/media\/([^\s\?]+\?format=[a-zA-Z0-9]+).*$/, //If this doesn't match the entire string, the substring that is not matched will be included, making the URL invalid
				ReplaceWith:["https://pbs.twimg.com/media/$1&name=orig", "https://pbs.twimg.com/media/$1&name=thumb"],
				IncludeOriginal:false
			},
			{
				//Example 2: Pagination test
				Type:"pagination",
				FindWhat:/(?:(?<=^https:\/\/example\.com\/[a-zA-Z0-9_]+\?page=))\d+(?:(?=.*$))/,
				PageNumberStartsAt:1
			},
			{
				//Example 3: Blacklisted test
				Type:"blacklisted",
				FindWhat:/http(s)?:\/\/(aa|about|accounts|adservice|apis|ads|mail|myactivity|policies|store|sustainability|www)?\.google(\.com)?(\/.*)?$/
			},
			{
				Type:"Blacklisted",
				FindWhat:/https:\/\/googleads.*$/
			}
		]
	function Auto_update() {
		if (document.getElementById("AutoUpdate").checked) {
			MainFunction()
		}
	}
	function ChangeFilterSettings(ElementClass, Setting) {
		//ElementClass: the element class to be affected by this function
		//Setting:
		//0 = uncheck
		//1 = check
		//2+ = invert
		if (Setting < 2) {
			for (let i = 0; i < document.getElementsByClassName(ElementClass).length; i++) {
				document.getElementsByClassName(ElementClass)[i].checked = Setting
			}
		} else {
			for (let i = 0; i < document.getElementsByClassName(ElementClass).length; i++) {
				document.getElementsByClassName(ElementClass)[i].checked = document.getElementsByClassName(ElementClass)[i].checked ^ 1
			}
		}
	}
	//Copy text from textarea
		function setClipboard(String) {
			//Credit goes to Mozilla: https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/write
			const type = "text/plain";
			const blob = new Blob([String], { type });
			const data = [new ClipboardItem({ [type]: blob })];
	
			navigator.clipboard.write(data).then(
				() => {
				/* success */
					document.getElementById("CopiedTextMessage").innerHTML = " <span style='color: #00FF00;'>Copied!</span>"
					setTimeout(DeleteCopyMessage, 1500)
				},
				() => {
				/* failure */
					document.getElementById("CopiedTextMessage").innerHTML = " <span style='color: #FF0000;'>Copy failed!</span>"
					setTimeout(DeleteCopyMessage, 1500)
				}
			);
		}
		function DeleteCopyMessage() {
			document.getElementById("CopiedTextMessage").innerHTML = ""
		}
	{
		let OutputSet = new Set() //Had to have set contain strings because if set contains any object and not primitive, would allow duplicates.
		let OutputURLObjects = [] //
		function MainFunction() {
			OutputSet = new Set() //Reset/clear them to not include previous versions
			OutputURLObjects = [] //
			document.getElementById("URL_OutputTable").innerHTML = ""
			if (InputChanged) {
				let ListOfURLs = document.getElementById("Input_EnteredURLs").value.match(/ttp(s)?\:\/\/(?!data:)[^\s\"\']+/g) //Why ttps instead of https? Blame firefox's URL truncation of long URLs.
				if (ListOfURLs == null) {
					ListOfURLs = [] //failsafe, prevents Array.map from performing a null which on the browser, would do nothing (if user enters a string with no valid URL).
				}
				ListOfURLs = ListOfURLs.map(ArrayElement => {
					
					let URLObject = {
						URL:ArrayElement.replace(/^ttp(s)?/, "http$1").replace(/#.*$/, ""), //Revert the URL to have the "h" of the http/https, and remove fragment identifier
						HaveBeenChecked:false, //This is used to check for duplicate or 2 URLs being similar (same URL but different page number)
						IdentifiedType:""
					}
					return URLObject
				});
		
				//Some loops had to use a for loop instead of array.foreach because
				//-Not recommended for concurrent modification since we are checking for potential same/similar URL
				//-We check every possible combinations, so there are two index numbers with the second one starting at FirstIndex+1 instead of 0.
				for (let i = 0; i < ListOfURLs.length; i++) { //Loop through every entered URL by the user
					let UrlMatchedAnyConverter = false
					if (ListOfURLs[i].HaveBeenChecked == false) { //Skip pagination URLs that have been checked by inner loop (optimization purposes)
						ListOfConverters.forEach(Converter => { //For each URL the user entered, loop through converters
							if (Converter.FindWhat.test(ListOfURLs[i].URL)) { //If URL matches one or more of the converters (a URL gets to loop through multiple converters)
								UrlMatchedAnyConverter = true
								if (Converter.IncludeOriginal) {
									//OutputSet.add(ListOfURLs[i].URL)
									ListOfURLs[i].IdentifiedType = "original"
									AddToOutput(ListOfURLs[i])
								}
								if (Converter.Type == "normal") {
									Converter.ReplaceWith.forEach(ReplaceWithText => {
										//OutputSet.add(ListOfURLs[i].URL.replace(Converter.FindWhat, ReplaceWithText))
										AddToOutput({
											URL:ListOfURLs[i].URL.replace(Converter.FindWhat, ReplaceWithText),
											IdentifiedType:"converted"
										});
									});
								} else if (Converter.Type == "pagination") {
									let HighestPageNumberSoFar = parseInt(ListOfURLs[i].URL.match(Converter.FindWhat)[0], 10)
									let PartsOfURLSame = ListOfURLs[i].URL.split(Converter.FindWhat)
									for (let i2 = i+1; i2 < ListOfURLs.length; i2++) { //Loop to find a potential same URL but with higher page number
										PartsOfURLSame2 = ListOfURLs[i2].URL.split(Converter.FindWhat)
										if (Converter.FindWhat.test(ListOfURLs[i2].URL) && (PartsOfURLSame[0] == PartsOfURLSame2[0]) && (PartsOfURLSame[1] == PartsOfURLSame2[1])) { //if regex and all parts of the URL the same ignoring page number, compare the page number
											HighestPageNumberSoFar = Math.max(HighestPageNumberSoFar, parseInt(ListOfURLs[i2].URL.match(Converter.FindWhat)[0], 10))
											ListOfURLs[i2].HaveBeenChecked = true //Don't check this again when the outer loop advances
										}
									}
									//We now have the maximum number based on the user input
									for (let i2 = Converter.PageNumberStartsAt; i2 <= HighestPageNumberSoFar; i2++) { //Generate a URL of each page
										//OutputSet.add(PartsOfURLSame[0] + i2.toString(10) + PartsOfURLSame[1])
										AddToOutput({
											URL:PartsOfURLSame[0] + i2.toString(10) + PartsOfURLSame[1],
											IdentifiedType:"pagination"
										});
									}
								} else if (Converter.Type == "blacklisted") {
									ListOfURLs[i].IdentifiedType = "blacklisted"
									AddToOutput(ListOfURLs[i])
								}
								
							}
						});
						if ((UrlMatchedAnyConverter == false)&&document.getElementById("FilterSetting_other").checked) {
							//OutputSet.add(ListOfURLs[i].URL)
							ListOfURLs[i].IdentifiedType = "other"
							AddToOutput(ListOfURLs[i])
						}
					}
				}
				//Save finished output array into storage
				SavedOutput = OutputURLObjects
				InputChanged = false //Reset this back to false so that if input change again, this above code will run
			} else {
				//Load
				OutputURLObjects = SavedOutput
			}
			let Filtered_OutputURLObjects = OutputURLObjects.filter(ArrayElement => {return document.getElementById("FilterSetting_" + ArrayElement.IdentifiedType).checked})
			if (document.getElementById("SortSetting_ABC").checked) {
				Filtered_OutputURLObjects.sort((a, b) => {
					if (a.URL === b.URL) {
						return 0;
					} else {
						return (a.URL < b.URL) ? -1 : 1;
					}
				});
			} else if (document.getElementById("SortSetting_ABC_Reverse").checked) {
				Filtered_OutputURLObjects.sort((a, b) => {
					if (a.URL === b.URL) {
						return 0;
					} else {
						return (a.URL < b.URL) ? 1 : -1;
					}
				});
			} else if (document.getElementById("SortSetting_IdentifiedType").checked) {
				Filtered_OutputURLObjects.sort((a, b) => {
					if (a.IdentifiedType === b.IdentifiedType) {
						return 0;
					} else {
						return (a.IdentifiedType < b.IdentifiedType) ? -1 : 1;
					}
				});
			} else if (document.getElementById("SortSetting_IdentifiedType_Reverse").checked) {
				Filtered_OutputURLObjects.sort((a, b) => {
					if (a.IdentifiedType === b.IdentifiedType) {
						return 0;
					} else {
						return (a.IdentifiedType < b.IdentifiedType) ? 1 : -1;
					}
				});
			}
			let OutputString = ""
			
			Filtered_OutputURLObjects.forEach((ArrayElement, ArrayIndex, ArrayItself) => {
				OutputString += ArrayElement.URL
				if (ArrayIndex != ArrayItself.length - 1) {
					OutputString += "\n"
				}
			});
			document.getElementById("HTML_OutputString").value = OutputString
			
			let OutputHTMLTableString = ""
			OutputHTMLTableString += "<table>"
			OutputHTMLTableString += "<tr><th>URL</th><th>Identified Type</th></tr>"
			Filtered_OutputURLObjects.forEach((ArrayElement) => {
				OutputHTMLTableString += "<tr><td><pre>"+escapeHTMLChars(ArrayElement.URL)+"</pre></td><td><pre>"+ArrayElement.IdentifiedType+"</pre></td></tr>"
			});
			OutputHTMLTableString += "</table>"
			document.getElementById("URL_OutputTable").innerHTML = OutputHTMLTableString
		}
		function AddToOutput(URLObject) {
			if (!OutputSet.has(URLObject.URL)) {
				OutputSet.add(URLObject.URL)
				OutputURLObjects.push(URLObject)
			}
		}
	}
	function escapeHTMLChars(string) {
		//Should the user's input contains "<", ">", and "&", prevent the innerHTML from treating these as HTML tags/escapes
			string = string.replaceAll("&", "&amp;") //This must be done first, to avoid replacing already-replaced symbol's ampersand character.
			string = string.replaceAll("<", "&lt;")
			string = string.replaceAll(">", "&gt;")
			string = string.replaceAll("\n", "<br>") //Again just in case if WBGS would ever use linebreaks in a cell.
			return string
	}
</script>